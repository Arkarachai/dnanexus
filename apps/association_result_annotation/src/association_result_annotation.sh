#!/bin/bash
# association_result_annotation 0.0.1
# Generated by dx-app-wizard.
#
# Basic execution pattern: Your app will run on a single machine from
# beginning to end.
#
# Your job's input variables (if any) will be loaded as environment
# variables before this script runs.  Any array inputs will be loaded
# as bash arrays.
#
# Any code outside of main() (or any entry point you may add) is
# ALWAYS executed, followed by running the entry point itself.
#
# See https://wiki.dnanexus.com/Developer-Portal for tutorials on how
# to modify this file.
set -x
main() {
	  echo "Value of input_file: '$input_file'"
		echo "Value of input_file: '$sql_file'"


    # The following line(s) use the dx command-line tool to download your file
    # inputs to the local file system using variable names for the filenames. To
    # recover the original filenames, you can use the output of "dx describe
    # "$variable" --name".

		input_filename=$(dx describe --name "$input_file")
		dx download "$input_file" -o input_file
		dx download "$sql_file" -o anno.db
		out_suffix=""

	# Create SQLite database


    # Fill in your application code here.
    #
    # To report any recognized errors in the correct format in
    # $HOME/job_error.json and exit this script, you can use the
    # dx-jobutil-report-error utility as follows:
    #
    #   dx-jobutil-report-error "My error message"
    #
    # Note however that this entire bash script is executed with -e
    # when running in the cloud, so any line which returns a nonzero
    # exit code will prematurely exit the script; if no error was
    # reported in the job_error.json file, then the failure reason
    # will be AppInternalError with a generic error message.

	# Seperate Var1_Pos to "chr" and "pos" columns

	awk 'BEGIN{OFS=FS="\t"}{gsub(":","\t",$3)}1' input_file | sed 's/Var1_Pos/chr\tPos/g' > up_input_file
	# Get the column names from input file

	icd_tbl_col=$(head -n1 up_input_file | sed 's/)//g' | sed 's/(//g' | sed 's/\t/ varchar(255),/g' | sed 's/$/ varchar(255)/g')

	# Create a table for input results file
	sqlite3 anno.db "create table assoc_result ($icd_tbl_col)"

	# Insert input results to the table.

	sqlite3 anno.db <<!
.separator \t
.import up_input_file assoc_result
delete from assoc_result where outcome='Outcome';
!

	# Import ICD-9 code description table to the database
	dx download "$DX_RESOURCES_ID:ICD9/icd9_codes_description.txt"  -o icd9_code_desc.txt
	sqlite3 anno.db <<!
create table icd9_code_desc (icd9_code varchar(8), desc text);
.header on
.separator "\t"
.import icd9_code_desc.txt icd9_code_desc
delete from icd9_code_desc where desc='desc';
!
	if [ "$gene" == true || "$up_gene" == true || "$down_gene" == true ];
	then
		# Create position file of SNPs from the association result file
		cut -f3,4 up_input_file |  sort -u  > input_file_snp_position.txt

		# Run biofilter to get gene, upstream gene, downstream gene and GWAS

		sudo mkdir /usr/share/biofilter
		sudo chmod a+rwx /usr/share/biofilter


		dx download -r "project-Bkp5fYQ0vqZfq1XXPkYK2p1z:/Biofilter/2.4/*" -o /usr/share/biofilter/
		dx download "project-Bkp5fYQ0vqZfq1XXPkYK2p1z:/LOKI/LOKI-20160428-noSNPs.db" -o /usr/share/biofilter/loki.db


		python2.7 /usr/share/biofilter/biofilter.py -v -k /usr/share/biofilter/loki.db --gbv 37 -P input_file_snp_position.txt -a position gene upstream downstream
		awk 'BEGIN{OFS=FS="\t"}{gsub(":","\t",$2)}1' biofilter.position.gene-upstream-downstream | sed 's/chr//g' | sed 's/position/chr_37\tpos_37/g' > biofilter_snp_anno
		# Import biofilter result into
		biofilter_anno_col=$(head -n1 biofilter_snp_anno | \
		sed 's/^#/chr/g' | \
		sed 's/\//_/g' | \
		sed 's/%/_/g'  | \
		awk 'BEGIN{OFS=FS="\t"}{gsub("distance","up_distance",$7)}1' | \
		awk 'BEGIN{OFS=FS="\t"}{gsub("distance","down_distance",$9)}1' | \
		sed 's/\t/ varchar(255),/g' | \
		sed 's/$/ varchar(255)/g' )

		sqlite3 anno.db "create table biofilter_anno ($biofilter_anno_col)"

		sqlite3 anno.db <<!
.separator \t
.import biofilter_snp_anno biofilter_anno
delete from biofilter_anno where chr='#';
!

	fi


	if [ "$icd9_desc" == true ];
	then
		icd9_join="left join icd9_code_desc b on a.outcome=b.icd9_code"
		icd9_select=",b.desc as icd9_description"
		out_suffix="_icd9-desc"

	fi
#exp(log(exp(Var1_beta)) - 1.96*Var1_SE) || ',' || exp(log(exp(Var1_beta)) + 1.96*Var1_SE) as OR_CI "
	if [ "$or_val" == true ];
	then
		or_val_query=",exp(var1_beta) as odds_ratio,round(exp(log(exp(Var1_beta)) - 1.96*Var1_SE),3) || ',' || round(exp(log(exp(Var1_beta)) + 1.96*Var1_SE),3) as OR_95CI"
		out_suffix="${out_suffix}_or"
	fi


	if $gene;
	then
		gene_query="left join biofilter_anno b on a.chr=b.chr_37 and a.Pos=b.pos_37"
		gene_col=",gene as Gene"
		out_suffix="${out_suffix}_gene"
	fi


	if $up_gene;
	then
		if [ "${gene_query}" != "" ]
		then
			up_gene_col=",b.upstream as 'Upstream Gene', b.up_distance as 'Upstream Distance'"
			out_suffix="${out_suffix}_up-gene"
		else
			gene_query="left join biofilter_anno b on a.chr=b.chr_37 and a.Pos=b.pos_37"
			up_gene_col=",b.upstream as 'Upstream Gene', b.up_distance as 'Upstream Distance'"
			out_suffix="${out_suffix}_up-gene"
		fi
	fi

	if $down_gene
	then
		if [ "${gene_query}" != "" ]
		then
			down_gene_col=",b.downstream as 'Downstream Gene', b.down_distance as 'Downstream Distance'"
			out_suffix="${out_suffix}_down-gene"
		else
			gene_guery="left join biofilter_anno b on a.chr=b.chr_37 and a.Pos=b.pos_37"
			down_gene_col=",b.downstream as 'Downstream Gene', b.down_distance as 'Downstream Distance'"
			out_suffix="${out_suffix}_down-gene"
		fi
	fi

	if [ "$case_control_num" == true ];
	then
		case_control_query=",Num_Cases as Cases, Num_NonMissing-Num_Cases as Controls"
		out_suffix="${out_suffix}_case-control"
	fi

	if [ "$ebi_gwas" == true ];
	then
		gwas_join='left join ebi_gwas_pos egp on a.chr=egp.chr and a.pos=egp.pos left join ebi_gwas eg on eg.chr_id=egp.chr_hg38 and eg.chr_pos=egp.pos_hg38'
		gwas_query=",group_concat(distinct eg.DISEASE_TRAIT) as GWAS_trait"
		out_suffix="${out_suffix}_gwas"
	fi

	if [ "$grasp" == true ];
	then
		grasp_join='left join grasp g on a.chr=g.chr and a.Pos=g.pos where g.Pvalue<0.00001'
		grasp_query=",group_concat(distinct Phenotype) as GRASP_Trait"
		out_suffix="${out_suffix}_grasp"
	fi

echo "
sqlite3 anno.db <<!
.load /usr/local/lib/libsqlitefunctions.so
.headers on
.mode tabs
.output ${input_filename}${out_suffix}
select a.* ${icd9_select} ${case_control_query} ${or_val_query} ${gene_col} ${up_gene_col} ${down_gene_col} ${gwas_query} ${grasp_query} from assoc_result a ${icd9_join} ${gene_query} ${gwas_join} ${grasp_join};
!
"

sqlite3 anno.db <<!
.load /usr/local/lib/libsqlitefunctions.so
.headers on
.mode tabs
.output ${input_filename}${out_suffix}
select a.* ${icd9_select} ${case_control_query} ${or_val_query} ${gene_col} ${up_gene_col} ${down_gene_col} ${gwas_query} ${grasp_query} from assoc_result a ${icd9_join} ${gene_query} ${gwas_join} ${grasp_join};
!
# The following line(s) use the dx command-line tool to upload your file
    # outputs after you have created them on the local file system.  It assumes
    # that you have used the output field name for the filename for each output,
    # but you can change that behavior to suit your needs.  Run "dx upload -h"
    # to see more options to set metadata.

    out_file=$(dx upload ${input_filename}${out_suffix} --brief)

    # The following line(s) use the utility dx-jobutil-add-output to format and
    # add output variables to your job's output as appropriate for the output
    # class.  Run "dx-jobutil-add-output -h" for more information on what it
    # does.

    dx-jobutil-add-output out_file "$out_file" --class=file
}
